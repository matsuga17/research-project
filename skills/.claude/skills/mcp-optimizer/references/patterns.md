# 最適化パターン詳細集

## 1. 結果保存パターン

### Pattern 1.1: 検索結果の効率的保存

**問題**: 検索結果の全情報がコンテキストを圧迫

**解決策**:
```
検索 → ファイル保存 → 要約のみ返却
```

**実装例**:
```
【非効率】
「Semantic Scholarでdynamic capabilitiesの論文を検索して」
→ 10件×全フィールド = 大量トークン消費

【最適化】
「Semantic Scholarでdynamic capabilitiesの論文を10件検索して、
/home/claude/papers/dc_papers.csv に以下の列で保存：
タイトル, 著者, 年, 引用数, DOI

私には「10件発見。最多引用はTeece(2007)で3,542回」とだけ報告」
```

**効果**: コンテキスト消費 約85%削減

### Pattern 1.2: 段階的詳細取得

**問題**: 最初から全詳細を取得し、多くが未使用

**解決策**:
```
概要取得 → 選択 → 選択分のみ詳細取得
```

**実装例**:
```
Step 1: 「論文を検索してタイトル一覧を保存」
Step 2: 「保存したリストを見せて」
Step 3: 「3番と7番のアブストラクトだけ取得して」
```

**効果**: 不要な詳細取得を回避、必要分のみ処理

### Pattern 1.3: バッチ処理と個別保存

**問題**: N件を個別に処理し、毎回結果が返却される

**解決策**:
```
N件一括処理 → 個別ファイル保存 → サマリーのみ返却
```

**実装例**:
```
「以下の5社について企業情報を収集：
Alibaba, Coupang, Sea Limited, Flipkart, Tokopedia

各社のデータは /home/claude/companies/{企業名}.json に保存。
私には「5社収集完了。売上規模順は1.Alibaba 2.Sea...」とだけ報告」
```

**効果**: 5回の返却→1回の要約返却

## 2. ワークフロー統合パターン

### Pattern 2.1: フェーズ分割実行

**問題**: 長い処理の途中経過が全てコンテキストに蓄積

**解決策**:
```
Phase分割 → 各Phase結果をファイル保存 → 完了通知のみ
```

**実装例**:
```
【Phase 1: 収集】
- 処理: データ収集
- 保存: /home/claude/data/raw/
- 報告: 「Phase 1完了。50件収集」

【Phase 2: 分析】（「続けて」で開始）
- 処理: 統計分析
- 保存: /home/claude/data/analysis.md
- 報告: 「Phase 2完了。3つの傾向を発見」

【Phase 3: 出力】（「続けて」で開始）
- 処理: レポート生成
- 出力: アーティファクト
```

**効果**: 中間結果のコンテキスト蓄積を防止

### Pattern 2.2: 複数ソース統合

**問題**: 各ソースからの結果が個別にコンテキストに返却

**解決策**:
```
複数ソース → 個別ファイル保存 → 統合分析 → 結論のみ返却
```

**実装例**:
```
「以下の3ソースから情報収集：
1. 学術論文（Semantic Scholar）→ /home/claude/research/academic.md
2. 業界レポート（Web検索）→ /home/claude/research/industry.md
3. ニュース（Exa）→ /home/claude/research/news.md

各ソース5件以上収集したら、統合分析して結論を3点で報告。
詳細は各ファイル参照」
```

### Pattern 2.3: 条件分岐の効率化

**問題**: 条件確認→結果返却→次の指示、の往復が多い

**解決策**:
```
条件と分岐を事前定義 → 自動判断で処理継続
```

**実装例**:
```
「論文を検索して以下のルールで処理：
- 10件以上見つかった場合: 引用数上位10件を保存
- 10件未満の場合: 全件保存して「件数不足」と報告
- 0件の場合: キーワードを広げて再検索を提案

結果は /home/claude/papers/ に保存」
```

## 3. 情報圧縮パターン

### Pattern 3.1: 返却情報の限定

**問題**: 必要な情報以上が返却される

**解決策**: 明示的に返却情報を指定

**指定テンプレート**:
```
「私に報告する情報：
- {必要情報1}
- {必要情報2}
- {必要情報3}
それ以外の詳細は不要」
```

### Pattern 3.2: 数値サマリー化

**問題**: 個別データの羅列で冗長

**解決策**: 統計サマリーのみ返却

**実装例**:
```
「収集したデータについて以下のサマリーだけ報告：
- 総件数
- 平均値/中央値
- 最大/最小
- 特筆すべき外れ値（あれば）

個別データの羅列は不要」
```

### Pattern 3.3: 差分報告

**問題**: 更新時に全データを再報告

**解決策**: 変更分のみ報告

**実装例**:
```
「前回の検索結果（/home/claude/papers/previous.csv）と比較して、
新規追加された論文のみ報告。
既存論文は報告不要」
```

## 4. エラー処理パターン

### Pattern 4.1: エラーのファイル記録

**問題**: エラー詳細が冗長にコンテキストを消費

**解決策**:
```
エラー詳細 → ファイル保存 → 要約のみ返却
```

**実装例**:
```
「処理中にエラーが発生した場合：
- エラー詳細: /home/claude/logs/errors.log に追記
- 私への報告: 「3件のエラー発生。詳細はerrors.log参照」のみ」
```

### Pattern 4.2: リトライの自動化

**問題**: 失敗→報告→リトライ指示の往復

**解決策**:
```
失敗時の自動リトライルールを事前定義
```

**実装例**:
```
「データ取得に失敗した場合：
- 3回まで自動リトライ
- 3回失敗したら失敗リストに記録して次へ進む
- 最終報告で失敗件数と成功件数をサマリー」
```

## パターン選択ガイド

| 状況 | 推奨パターン |
|------|-------------|
| 検索結果が大量 | Pattern 1.1 + 1.2 |
| 複数対象の同一処理 | Pattern 1.3 |
| 長いワークフロー | Pattern 2.1 |
| 複数情報源 | Pattern 2.2 |
| 条件分岐が多い | Pattern 2.3 |
| 不要情報が混入 | Pattern 3.1 |
| データ分析結果 | Pattern 3.2 |
| 定期更新タスク | Pattern 3.3 |
| エラーが頻発 | Pattern 4.1 + 4.2 |
