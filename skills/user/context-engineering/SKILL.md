---
name: context-engineering
description: "AIエージェントのコンテキストウィンドウを最適化し、複雑なタスクの信頼性を向上させる設計原則とワークフロー。HumanLayerの12 Factor Agents、ACE-FCA（Advanced Context Engineering for Coding Agents）に基づく。Research-Plan-Implement 3フェーズ構造、意図的コンパクション、サブエージェントパターンを提供。"
---

# Context Engineering for AI Agents
# AIエージェントのためのコンテキストエンジニアリング

**Version**: 1.0.0
**Created**: 2025-12-06
**Based on**: HumanLayer 12 Factor Agents, ACE-FCA

---

## エグゼクティブサマリー

Context Engineeringは、AIエージェント（特にLLM）のコンテキストウィンドウを戦略的に管理し、複雑なタスクの成功率を向上させる設計手法である。

### 核心的洞察

> "LLMはステートレスである。出力の品質は入力トークンの品質に直接相関する。"
> — HumanLayer ACE-FCA

### 主要原則

1. **コンテキストは希少資源** — 無制限ではなく、予算として管理
2. **意図的コンパクション** — 各フェーズ完了時に情報を圧縮
3. **Research-Plan-Implement** — 3フェーズの構造化ワークフロー
4. **サブエージェント委譲** — 調査タスクを分離し、要約のみ受け取る

### 期待効果

| 指標 | 改善前 | 改善後 |
|------|--------|--------|
| タスク完了率 | 70-80% | 90-95% |
| コンテキスト効率 | 60-100%使用 | 40-60%使用 |
| エラー復旧 | 手動介入 | 自動リトライ |
| 複雑タスク対応 | 困難 | 可能 |

---

## 1. コンテキストウィンドウの理解

### 1.1 コンテキストの「ダムゾーン」問題

HumanLayerの研究（100,000開発者セッション分析）により、コンテキストウィンドウの中央40-60%で**モデルの想起と推論が劣化**することが判明。

```
コンテキストウィンドウ構造：

[0-20%]     ← 高精度ゾーン（システムプロンプト、重要指示）
[20-40%]    ← 良好ゾーン
[40-60%]    ← ⚠️ ダムゾーン（想起・推論が劣化）
[60-80%]    ← 良好ゾーン
[80-100%]   ← 高精度ゾーン（最新の会話、直近の指示）
```

### 1.2 最適なコンテキスト使用率

**目標：40-60%の使用率を維持**

| 使用率 | 状態 | 推奨アクション |
|--------|------|----------------|
| 0-40% | 最適 | そのまま継続 |
| 40-60% | 許容範囲 | 監視継続 |
| 60-80% | 警告 | 意図的コンパクション実施 |
| 80-100% | 危険 | 即座にコンパクションまたはリセット |

### 1.3 コンテキスト品質の優先順位

1. **正確性** — 誤った情報が最も危険
2. **完全性** — 欠落情報は次に悪い
3. **ノイズレス性** — 余分な情報は避ける

---

## 2. Research-Plan-Implement ワークフロー

### 2.1 概要

すべての複雑なタスクを3フェーズに分解する：

```
┌─────────────────────────────────────────────────────────┐
│                    複雑なタスク                          │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Research   │ → │    Plan     │ → │  Implement   │
│   (調査)     │    │   (計画)    │    │   (実装)    │
└─────────────┘    └─────────────┘    └─────────────┘
      ↓                  ↓                  ↓
 research.md         plan.md          output/result
 (圧縮済み)          (圧縮済み)
```

### 2.2 Research フェーズ

**目的**: コードベース/資料の客観的理解と関連情報の特定

**実行内容**:
- 構造の把握
- 関連ファイル/セクションの特定
- 情報フローと依存関係の理解
- 潜在的な問題点の発見

**成果物**: `research-summary.md`（500字以内）

**テンプレート**:
```markdown
## Research Summary

### 理解した構造
- [箇条書き3-5項目]

### 関連ファイル/リソース
- [ファイルパスまたはリソース名、各1行]

### 主要な発見
- [重要な発見3-5項目]

### 潜在的課題
- [課題2-3項目]

### 次フェーズへの推奨
- [具体的な推奨1-2項目]
```

### 2.3 Plan フェーズ

**目的**: 具体的な実装ステップの策定

**入力**: `research-summary.md`のみ（詳細な調査結果は参照しない）

**実行内容**:
- 実装ステップの定義
- 各ステップの依存関係明示
- テスト/検証手順の策定
- リスクと代替案の特定

**成果物**: `implementation-plan.md`（800字以内）

**テンプレート**:
```markdown
## Implementation Plan

### 目標
[1-2文で明確に記述]

### 実装ステップ
1. [ステップ1]: [詳細]
2. [ステップ2]: [詳細]
3. [ステップ3]: [詳細]
...

### 依存関係
- Step X は Step Y の完了後に実行

### テスト/検証
- [検証項目1]
- [検証項目2]

### リスクと代替案
- リスク: [リスク記述] → 代替: [代替案]
```

### 2.4 Implement フェーズ

**目的**: 計画に基づく実行

**入力**: `implementation-plan.md`のみ

**実行内容**:
- 計画に沿った逐次実行
- 各ステップ完了後の状態更新
- エラー発生時のコンパクトな記録

**成果物**: 最終出力（コード、ドキュメント、分析結果など）

---

## 3. 意図的コンパクション

### 3.1 コンパクションとは

各フェーズ完了時に、**進捗と発見を圧縮して要約**し、次フェーズには要約のみを引き継ぐ手法。

### 3.2 コンパクションのタイミング

| タイミング | アクション |
|------------|-----------|
| Research完了時 | 調査結果を500字以内に圧縮 |
| Plan完了時 | 計画を800字以内に圧縮 |
| 各Implementステップ完了時 | 完了状態を1-2文で記録 |
| エラー発生時 | エラーを100字以内で記録 |

### 3.3 コンパクションの原則

**DO（すべきこと）**:
- 結論と決定事項を優先
- 具体的な数値・名前を保持
- 次フェーズに必要な情報のみ抽出

**DON'T（避けるべきこと）**:
- 詳細な過程の記録
- 検討したが却下した選択肢の詳細
- 冗長な説明

### 3.4 コンパクション例

**Before（圧縮前）**:
```
src/ディレクトリを調査したところ、componentsフォルダには
Button.tsx、Input.tsx、Modal.tsx、Card.tsx、Table.tsxがあり、
それぞれがReactコンポーネントとして実装されている。
Button.tsxは230行で、variantとsizeのpropsを受け取り、
Tailwind CSSでスタイリングされている。また、disabled状態の
ハンドリングも含まれている。Input.tsxは180行で...
（以下、各ファイルの詳細が続く）
```

**After（圧縮後）**:
```
## 構造: src/components/に5つのUIコンポーネント
## 技術: React + Tailwind CSS
## 注目: Button.tsx（230行）が最大、variant/sizeパターン使用
## 課題: 共通スタイルの重複あり
```

---

## 4. サブエージェントパターン

### 4.1 概要

調査タスクを**独立したサブエージェントに委譲**し、メインエージェントは**要約のみを受け取る**パターン。

### 4.2 構造

```
┌─────────────────────────────────────────────┐
│              メインエージェント               │
│         (コンテキストをクリーンに保持)        │
└─────────────────────────────────────────────┘
        ↓ タスク委譲        ↑ 要約のみ返却
┌───────────┐  ┌───────────┐  ┌───────────┐
│ サブAgent A │  │ サブAgent B │  │ サブAgent C │
│  (調査1)   │  │  (調査2)   │  │  (調査3)   │
└───────────┘  └───────────┘  └───────────┘
```

### 4.3 サブエージェントの原則

**サブエージェントの責務**:
- 特定の調査タスクに集中
- 詳細な探索を実行
- 結果を圧縮して返却

**メインエージェントの責務**:
- タスクの分解と委譲
- 要約の統合
- 最終的な意思決定

### 4.4 適用例

```
タスク: 「認証システムのバグを修正」

メインエージェント:
  → サブAgent A: 「認証関連ファイルを特定し、構造を要約」
  → サブAgent B: 「エラーログを分析し、原因候補を3つ挙げる」
  → サブAgent C: 「類似バグの過去の修正パターンを調査」

各サブエージェントから要約（各200字以内）を受け取り、
メインエージェントが統合して修正方針を決定
```

---

## 5. 12 Factor Agents（要約）

HumanLayerが提唱するプロダクション品質のLLMアプリケーション設計原則：

| Factor | 原則 | 適用方法 |
|--------|------|----------|
| 1 | Natural Language to Tool Calls | 自然言語を構造化ツール呼び出しに変換 |
| 2 | Own Your Prompts | プロンプトを自分で管理（フレームワーク任せにしない） |
| 3 | **Own Your Context Window** | コンテキストを戦略的に管理 |
| 4 | Tools as Structured Outputs | ツール呼び出しを構造化出力として扱う |
| 5 | Unify Execution & Business State | エージェント状態とアプリ状態を同期 |
| 6 | **Launch/Pause/Resume APIs** | 起動・一時停止・再開の設計 |
| 7 | Contact Humans with Tool Calls | 人間への問い合わせをツール化 |
| 8 | **Own Your Control Flow** | 制御フローを明示的に管理 |
| 9 | **Compact Errors into Context** | エラーを効率的にコンテキストに圧縮 |
| 10 | **Small, Focused Agents** | 小さく焦点を絞ったエージェント |
| 11 | Trigger from Anywhere | 様々なトリガーに対応 |
| 12 | Stateless Reducer Pattern | ステートレスなReducerパターン |

**太字**はContext Engineeringに特に関連する原則。

---

## 6. 他スキルへの統合ガイド

### 6.1 統合セクションテンプレート

既存スキルに以下のセクションを追加することで、Context Engineering原則を適用できる：

```markdown
---

## Context Engineering Integration

### コンテキスト予算管理

**使用率目標**: 40-60%

**監視ポイント**:
- [スキル固有の監視ポイント1]
- [スキル固有の監視ポイント2]

**制限ルール**:
- [スキル固有の制限1]
- [スキル固有の制限2]

### フェーズ間情報引継ぎ

**[フェーズ1名]完了時**:
- 成果物を[X]字以内に圧縮
- 次フェーズには圧縮版のみ引継ぎ

**[フェーズ2名]完了時**:
- 成果物を[Y]字以内に圧縮
- 最終フェーズには圧縮版のみ引継ぎ

### コンパクション実行条件

| 条件 | アクション |
|------|-----------|
| 使用率40%超過 | [アクション1] |
| 使用率60%超過 | [アクション2] |
| エラー発生 | [アクション3] |

---
```

### 6.2 スキル別適用ガイドライン

**マルチエージェント型スキル**（例：recursive-think）:
- エージェント数の動的制限
- 各エージェント出力の圧縮ルール
- エージェント間情報引継ぎの最小化

**ワークフロー型スキル**（例：mcp-builder、academic-paper-30k-creator）:
- 既存フェーズをResearch-Plan-Implementにマッピング
- フェーズ間のコンパクションポイント定義

**理論構築型スキル**（例：theory-building、exploratory-theory-building）:
- 仮説生成時の出力制限
- 検討却下案の非保持
- 対話ラウンド制限

---

## 7. アンチパターン

### 7.1 避けるべきパターン

**アンチパターン1: コンテキスト肥大化**
```
❌ すべての調査結果を詳細に保持
❌ 検討したが却下した選択肢を記録
❌ 過去の会話履歴をすべて参照
```

**アンチパターン2: 無計画な実行**
```
❌ 調査と実装を同時進行
❌ 計画なしにコード修正開始
❌ エラー発生時の場当たり的対応
```

**アンチパターン3: モノリシックエージェント**
```
❌ 1つのエージェントですべてを処理
❌ サブタスク分解なし
❌ 10ステップ以上の連続処理
```

### 7.2 推奨パターン

**推奨パターン1: 計画的コンテキスト管理**
```
✅ 各フェーズ完了時に圧縮
✅ 必要な情報のみ次フェーズに引継ぎ
✅ 定期的なコンテキスト使用率確認
```

**推奨パターン2: 構造化ワークフロー**
```
✅ Research → Plan → Implement の順序遵守
✅ 各フェーズの成果物を明確に定義
✅ フェーズ間の依存関係を明示
```

**推奨パターン3: 小さく焦点を絞ったエージェント**
```
✅ 1エージェント = 1責務
✅ 3-10ステップで完了するタスク設計
✅ サブエージェントへの適切な委譲
```

---

## 8. 参考資料

### 8.1 HumanLayerリソース

- [12 Factor Agents](https://github.com/humanlayer/12-factor-agents)
- [Advanced Context Engineering for Coding Agents](https://github.com/humanlayer/advanced-context-engineering-for-coding-agents)
- [HumanLayer公式サイト](https://www.humanlayer.dev/)

### 8.2 関連スキル

本スキルの原則は以下のスキルと統合して使用できる：

- **skill-creator**: スキル設計時のContext Engineering適用
- **mcp-builder**: MCPサーバー開発時のエージェント中心設計
- **recursive-think**: マルチエージェント思考システムの最適化
- **theory-building**: 理論構築対話の効率化

---

## バージョン履歴

| バージョン | 日付 | 変更内容 |
|------------|------|----------|
| 1.0.0 | 2025-12-06 | 初版リリース |

---

**End of SKILL.md**
